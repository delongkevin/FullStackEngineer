<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texas Hold'em Poker</title>
    <style>
        /* All your existing CSS styles remain the same */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0a5c36, #0d7745);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            width: 100%;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            width: 100%;
        }

        h1 {
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
        }

        .player-info, .pot-info, .phase-info {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .pot-amount {
            font-size: 1.8rem;
            font-weight: bold;
            color: gold;
        }

        .phase-display {
            font-size: 1.2rem;
            font-weight: bold;
            color: #ffcc00;
        }

        .table-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #0a5c36;
            border-radius: 50%;
            border: 15px solid #8B4513;
            margin-bottom: 30px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .community-cards {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .card {
            width: 80px;
            height: 120px;
            background: white;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            color: black;
            font-weight: bold;
            position: relative;
        }

        .card.red {
            color: #d40000;
        }

        .card-back {
            background: linear-gradient(45deg, #1a5fb4, #3584e4);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
        }

        .card-top, .card-bottom {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .card-bottom {
            transform: rotate(180deg);
        }

        .card-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
        }

        .players-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }

        .player {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            transition: all 0.3s;
            position: relative;
        }

        .player.active {
            background: rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 15px gold;
        }

        .player.dealer::before {
            content: "D";
            position: absolute;
            top: -10px;
            right: -10px;
            background: gold;
            color: black;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }

        .player.small-blind::before {
            content: "SB";
            position: absolute;
            top: -10px;
            left: -10px;
            background: #4CAF50;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.7rem;
        }

        .player.big-blind::before {
            content: "BB";
            position: absolute;
            top: -10px;
            left: -10px;
            background: #F44336;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.7rem;
        }

        .player-cards {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }

        .player-cards .card {
            width: 60px;
            height: 90px;
            font-size: 0.8rem;
        }

        .player-name {
            font-weight: bold;
            font-size: 1.2rem;
        }

        .player-stack {
            color: gold;
            font-weight: bold;
        }

        .player-bet {
            margin-top: 5px;
            color: #ffcc00;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
        }

        .fold {
            background: #ff4d4d;
            color: white;
        }

        .check {
            background: #4CAF50;
            color: white;
        }

        .call {
            background: #2196F3;
            color: white;
        }

        .raise {
            background: #FF9800;
            color: white;
        }

        .all-in {
            background: #9C27B0;
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }

        .action-btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .betting-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }

        .chip-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .chip {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
            cursor: pointer;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }

        .chip:hover {
            transform: scale(1.1);
        }

        .chip-1 {
            background: white;
            color: black;
            border: 2px solid #ccc;
        }

        .chip-5 {
            background: red;
            border: 2px solid #a00;
        }

        .chip-25 {
            background: green;
            border: 2px solid #060;
        }

        .chip-100 {
            background: black;
            border: 2px solid #333;
        }

        .chip-500 {
            background: purple;
            border: 2px solid #505;
        }

        .bet-amount {
            font-size: 1.5rem;
            font-weight: bold;
            color: gold;
            margin: 10px 0;
        }

        .slider-container {
            width: 100%;
            margin: 10px 0;
        }

        input[type="range"] {
            width: 100%;
        }

        .game-log {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            max-height: 150px;
            overflow-y: auto;
            width: 100%;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .hand-ranking {
            position: absolute;
            bottom: -25px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .players-container {
                flex-direction: column;
                align-items: center;
            }
            
            .player {
                width: 100%;
                max-width: 300px;
            }
            
            .table-container {
                height: 300px;
            }
            
            .card {
                width: 60px;
                height: 90px;
            }
            
            .player-cards .card {
                width: 50px;
                height: 75px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Texas Hold'em Poker</h1>
            <p>Follows official poker rules with proper betting rounds</p>
        </header>

        <div class="game-info">
            <div class="player-info">
                <div>Player: <span id="player-name">You</span></div>
                <div>Stack: $<span id="player-stack">1500</span></div>
                <div>Current Bet: $<span id="player-current-bet">0</span></div>
            </div>
            <div class="pot-info">
                <div>Pot</div>
                <div class="pot-amount">$<span id="pot-amount">0</span></div>
            </div>
            <div class="phase-info">
                <div>Game Phase</div>
                <div class="phase-display" id="phase-display">Pre-flop</div>
            </div>
        </div>

        <div class="table-container">
            <div class="community-cards" id="community-cards">
                <!-- Community cards will be inserted here -->
            </div>
        </div>

        <div class="players-container">
            <!-- Player positions will be inserted here -->
        </div>

        <div class="controls">
            <button class="action-btn fold" id="fold-btn">Fold</button>
            <button class="action-btn check" id="check-btn">Check</button>
            <button class="action-btn call" id="call-btn">Call $0</button>
            <button class="action-btn raise" id="raise-btn">Raise</button>
            <button class="action-btn all-in" id="allin-btn">All In</button>
        </div>

        <div class="betting-controls">
            <div class="chip-selector">
                <div class="chip chip-1" data-value="1">$1</div>
                <div class="chip chip-5" data-value="5">$5</div>
                <div class="chip chip-25" data-value="25">$25</div>
                <div class="chip chip-100" data-value="100">$100</div>
                <div class="chip chip-500" data-value="500">$500</div>
            </div>
            <div class="slider-container">
                <input type="range" id="bet-slider" min="0" max="1500" value="0" step="5">
            </div>
            <div class="bet-amount">Bet: $<span id="bet-amount">0</span></div>
            <button class="action-btn" id="place-bet-btn" style="background: #FF5722;">Place Bet</button>
        </div>

        <div class="game-log">
            <h3>Game Log</h3>
            <div id="log-entries">
                <div class="log-entry">Welcome to Texas Hold'em Poker!</div>
                <div class="log-entry">Game started. Blinds posted.</div>
            </div>
        </div>
    </div>

    <script>
        // Game state with proper poker rules
        const gameState = {
            players: [
                { id: 1, name: "You", stack: 1500, bet: 0, cards: [], isActive: true, isFolded: false, isAllIn: false, position: 0 },
                { id: 2, name: "Player 2", stack: 1500, bet: 0, cards: [], isActive: false, isFolded: false, isAllIn: false, position: 1 },
                { id: 3, name: "Player 3", stack: 1500, bet: 0, cards: [], isActive: false, isFolded: false, isAllIn: false, position: 2 },
                { id: 4, name: "Player 4", stack: 1500, bet: 0, cards: [], isActive: false, isFolded: false, isAllIn: false, position: 3 }
            ],
            communityCards: [],
            pot: 0,
            currentBet: 0,
            currentPlayerIndex: 0,
            dealerPosition: 0,
            smallBlindPosition: 1,
            bigBlindPosition: 2,
            smallBlindAmount: 10,
            bigBlindAmount: 20,
            gamePhase: 'preflop', // preflop, flop, turn, river, showdown
            betAmount: 0,
            lastRaiseAmount: 0,
            bettingRoundComplete: false,
            deck: [],
            actionRequired: false,
            firstPlayerIndex: 0 // Track the first player in each betting round
        };

        // Card deck
        const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

        // Hand rankings
        const handRankings = {
            'high-card': 1,
            'pair': 2,
            'two-pair': 3,
            'three-of-a-kind': 4,
            'straight': 5,
            'flush': 6,
            'full-house': 7,
            'four-of-a-kind': 8,
            'straight-flush': 9,
            'royal-flush': 10
        };

        // Initialize the game
        document.addEventListener('DOMContentLoaded', function() {
            initializeGame();
            setupEventListeners();
            startNewHand();
        });

        function initializeGame() {
            // Create player elements
            const playersContainer = document.querySelector('.players-container');
            playersContainer.innerHTML = '';
            
            gameState.players.forEach(player => {
                const playerEl = document.createElement('div');
                playerEl.className = `player ${player.isActive ? 'active' : ''}`;
                playerEl.id = `player-${player.id}`;
                
                playerEl.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    <div class="player-stack">$${player.stack}</div>
                    <div class="player-cards">
                        <div class="card card-back"></div>
                        <div class="card card-back"></div>
                    </div>
                    <div class="player-bet">Bet: $${player.bet}</div>
                `;
                
                playersContainer.appendChild(playerEl);
            });
        }

        function setupEventListeners() {
            // Chip selection
            document.querySelectorAll('.chip').forEach(chip => {
                chip.addEventListener('click', function() {
                    const value = parseInt(this.getAttribute('data-value'));
                    gameState.betAmount += value;
                    updateBetControls();
                });
            });

            // Bet slider
            document.getElementById('bet-slider').addEventListener('input', function() {
                gameState.betAmount = parseInt(this.value);
                updateBetControls();
            });

            // Place bet button
            document.getElementById('place-bet-btn').addEventListener('click', function() {
                placeBet();
            });

            // Action buttons
            document.getElementById('fold-btn').addEventListener('click', function() {
                fold();
            });

            document.getElementById('check-btn').addEventListener('click', function() {
                check();
            });

            document.getElementById('call-btn').addEventListener('click', function() {
                call();
            });

            document.getElementById('raise-btn').addEventListener('click', function() {
                raise();
            });

            document.getElementById('allin-btn').addEventListener('click', function() {
                allIn();
            });
        }

        function startNewHand() {
            // Reset game state for new hand
            gameState.communityCards = [];
            gameState.pot = 0;
            gameState.currentBet = 0;
            gameState.betAmount = 0;
            gameState.lastRaiseAmount = 0;
            gameState.bettingRoundComplete = false;
            gameState.actionRequired = false;
            
            // Reset player states
            gameState.players.forEach(player => {
                player.bet = 0;
                player.cards = [];
                player.isFolded = false;
                player.isAllIn = false;
                player.isActive = false;
            });
            
            // Move dealer button
            gameState.dealerPosition = (gameState.dealerPosition + 1) % gameState.players.length;
            gameState.smallBlindPosition = (gameState.dealerPosition + 1) % gameState.players.length;
            gameState.bigBlindPosition = (gameState.dealerPosition + 2) % gameState.players.length;
            
            // Post blinds
            const smallBlindPlayer = gameState.players[gameState.smallBlindPosition];
            const bigBlindPlayer = gameState.players[gameState.bigBlindPosition];
            
            const smallBlindBet = Math.min(gameState.smallBlindAmount, smallBlindPlayer.stack);
            const bigBlindBet = Math.min(gameState.bigBlindAmount, bigBlindPlayer.stack);
            
            smallBlindPlayer.bet = smallBlindBet;
            smallBlindPlayer.stack -= smallBlindBet;
            
            bigBlindPlayer.bet = bigBlindBet;
            bigBlindPlayer.stack -= bigBlindBet;
            
            gameState.pot = smallBlindBet + bigBlindBet;
            gameState.currentBet = bigBlindBet;
            
            // Create and shuffle deck
            gameState.deck = createDeck();
            shuffleDeck(gameState.deck);
            
            // Deal cards
            dealCards();
            
            // Set first active player (after big blind)
            gameState.currentPlayerIndex = (gameState.bigBlindPosition + 1) % gameState.players.length;
            gameState.players[gameState.currentPlayerIndex].isActive = true;
            
            // Track the first player in this betting round
            gameState.firstPlayerIndex = gameState.currentPlayerIndex;
            
            // Update UI
            updateUI();
            updatePlayerPositions();
            
            // Add log entries
            addLogEntry(`New hand started. Dealer: ${gameState.players[gameState.dealerPosition].name}`);
            addLogEntry(`Small blind: ${smallBlindPlayer.name} posts $${smallBlindBet}`);
            addLogEntry(`Big blind: ${bigBlindPlayer.name} posts $${bigBlindBet}`);
            
            // If it's the human player's turn, enable controls
            if (gameState.currentPlayerIndex === 0) {
                enablePlayerControls();
            } else {
                // AI player's turn
                simulateAIPlayer();
            }
        }

        function createDeck() {
            const deck = [];
            for (const suit of suits) {
                for (const rank of ranks) {
                    deck.push({
                        rank: rank,
                        suit: suit,
                        isRed: suit === 'hearts' || suit === 'diamonds'
                    });
                }
            }
            return deck;
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function dealCards() {
            // Deal two cards to each player
            for (let i = 0; i < 2; i++) {
                for (const player of gameState.players) {
                    if (player.stack > 0) { // Only deal to players with chips
                        player.cards.push(gameState.deck.pop());
                    }
                }
            }
            
            // Update player card displays
            updatePlayerCards();
        }

        function updatePlayerCards() {
            gameState.players.forEach(player => {
                const playerEl = document.getElementById(`player-${player.id}`);
                const cardsContainer = playerEl.querySelector('.player-cards');
                cardsContainer.innerHTML = '';
                
                player.cards.forEach(card => {
                    const cardEl = document.createElement('div');
                    
                    if (player.id === 1 || gameState.gamePhase === 'showdown') {
                        // Show player's own cards or all cards at showdown
                        cardEl.className = `card ${card.isRed ? 'red' : ''}`;
                        cardEl.innerHTML = `
                            <div class="card-top">
                                <div>${card.rank}</div>
                                <div>${getSuitSymbol(card.suit)}</div>
                            </div>
                            <div class="card-center">${getSuitSymbol(card.suit)}</div>
                            <div class="card-bottom">
                                <div>${card.rank}</div>
                                <div>${getSuitSymbol(card.suit)}</div>
                            </div>
                        `;
                    } else {
                        // Face down card for opponents
                        cardEl.className = 'card card-back';
                        cardEl.textContent = 'POKER';
                    }
                    
                    cardsContainer.appendChild(cardEl);
                });
                
                // Show hand ranking at showdown
                if (gameState.gamePhase === 'showdown' && !player.isFolded) {
                    const handRank = evaluateHand(player.cards, gameState.communityCards);
                    const handRankEl = document.createElement('div');
                    handRankEl.className = 'hand-ranking';
                    handRankEl.textContent = handRank.name;
                    cardsContainer.appendChild(handRankEl);
                }
            });
        }

        function getSuitSymbol(suit) {
            switch(suit) {
                case 'hearts': return '♥';
                case 'diamonds': return '♦';
                case 'clubs': return '♣';
                case 'spades': return '♠';
                default: return '';
            }
        }

        function updateUI() {
            // Update player info
            document.getElementById('player-stack').textContent = gameState.players[0].stack;
            document.getElementById('player-current-bet').textContent = gameState.players[0].bet;
            
            // Update pot
            document.getElementById('pot-amount').textContent = gameState.pot;
            
            // Update phase
            document.getElementById('phase-display').textContent = gameState.gamePhase.charAt(0).toUpperCase() + gameState.gamePhase.slice(1);
            
            // Update player active states
            gameState.players.forEach((player, index) => {
                const playerEl = document.getElementById(`player-${player.id}`);
                if (player.isActive) {
                    playerEl.classList.add('active');
                } else {
                    playerEl.classList.remove('active');
                }
                
                // Update player bet display
                playerEl.querySelector('.player-bet').textContent = `Bet: $${player.bet}`;
                playerEl.querySelector('.player-stack').textContent = `$${player.stack}`;
                
                // Update folded state
                if (player.isFolded) {
                    playerEl.style.opacity = '0.6';
                } else {
                    playerEl.style.opacity = '1';
                }
            });
            
            // Update call button text
            const callAmount = gameState.currentBet - gameState.players[0].bet;
            document.getElementById('call-btn').textContent = `Call $${callAmount > 0 ? callAmount : 0}`;
            
            // Update community cards
            updateCommunityCards();
            
            // Update bet controls
            updateBetControls();
        }

        function updatePlayerPositions() {
            gameState.players.forEach(player => {
                const playerEl = document.getElementById(`player-${player.id}`);
                playerEl.classList.remove('dealer', 'small-blind', 'big-blind');
                
                if (player.position === gameState.dealerPosition) {
                    playerEl.classList.add('dealer');
                } else if (player.position === gameState.smallBlindPosition) {
                    playerEl.classList.add('small-blind');
                } else if (player.position === gameState.bigBlindPosition) {
                    playerEl.classList.add('big-blind');
                }
            });
        }

        function updateCommunityCards() {
            const communityCardsEl = document.getElementById('community-cards');
            communityCardsEl.innerHTML = '';
            
            // Show actual community cards based on game phase
            const cardsToShow = {
                'preflop': 0,
                'flop': 3,
                'turn': 4,
                'river': 5,
                'showdown': 5
            }[gameState.gamePhase] || 0;
            
            for (let i = 0; i < cardsToShow; i++) {
                const card = gameState.communityCards[i];
                const cardEl = document.createElement('div');
                cardEl.className = `card ${card.isRed ? 'red' : ''}`;
                cardEl.innerHTML = `
                    <div class="card-top">
                        <div>${card.rank}</div>
                        <div>${getSuitSymbol(card.suit)}</div>
                    </div>
                    <div class="card-center">${getSuitSymbol(card.suit)}</div>
                    <div class="card-bottom">
                        <div>${card.rank}</div>
                        <div>${getSuitSymbol(card.suit)}</div>
                    </div>
                `;
                communityCardsEl.appendChild(cardEl);
            }
            
            // Add placeholder cards for remaining community cards
            for (let i = cardsToShow; i < 5; i++) {
                const cardEl = document.createElement('div');
                cardEl.className = 'card card-back';
                cardEl.textContent = 'POKER';
                communityCardsEl.appendChild(cardEl);
            }
        }

        function updateBetControls() {
            document.getElementById('bet-amount').textContent = gameState.betAmount;
            document.getElementById('bet-slider').value = gameState.betAmount;
            
            // Update slider max based on player stack
            const maxBet = gameState.players[0].stack;
            document.getElementById('bet-slider').max = maxBet;
            
            // Set minimum raise amount
            const minRaise = gameState.currentBet + (gameState.lastRaiseAmount || gameState.bigBlindAmount);
            if (gameState.betAmount < minRaise && gameState.betAmount < maxBet) {
                gameState.betAmount = minRaise;
                document.getElementById('bet-amount').textContent = gameState.betAmount;
                document.getElementById('bet-slider').value = gameState.betAmount;
            }
        }

        function placeBet() {
            if (gameState.betAmount <= 0) return;
            
            const player = gameState.players[0];
            const actualBet = Math.min(gameState.betAmount, player.stack);
            const totalBet = player.bet + actualBet;
            
            // Check if this is a raise
            if (totalBet > gameState.currentBet) {
                gameState.lastRaiseAmount = totalBet - gameState.currentBet;
                gameState.currentBet = totalBet;
            }
            
            player.bet = totalBet;
            player.stack -= actualBet;
            gameState.pot += actualBet;
            
            addLogEntry(`${player.name} bets $${actualBet}`);
            
            // Reset bet amount
            gameState.betAmount = 0;
            updateBetControls();
            updateUI();
            
            // Move to next player
            nextPlayer();
        }

        function fold() {
            const player = gameState.players[0];
            player.isFolded = true;
            player.isActive = false;
            
            addLogEntry(`${player.name} folds`);
            
            // Move to next player
            nextPlayer();
        }

        function check() {
            const player = gameState.players[0];
            
            // Verify that checking is allowed (current bet is matched)
            if (player.bet < gameState.currentBet) {
                addLogEntry("Cannot check - you must call or fold");
                return;
            }
            
            addLogEntry(`${player.name} checks`);
            
            // Move to next player
            nextPlayer();
        }

        function call() {
            const player = gameState.players[0];
            const callAmount = gameState.currentBet - player.bet;
            
            if (callAmount <= 0) {
                check();
                return;
            }
            
            const actualCall = Math.min(callAmount, player.stack);
            
            player.bet += actualCall;
            player.stack -= actualCall;
            gameState.pot += actualCall;
            
            addLogEntry(`${player.name} calls $${actualCall}`);
            
            updateUI();
            
            // Move to next player
            nextPlayer();
        }

        function raise() {
            // Set bet amount to minimum raise
            const minRaise = gameState.currentBet + (gameState.lastRaiseAmount || gameState.bigBlindAmount);
            gameState.betAmount = Math.min(minRaise, gameState.players[0].stack);
            updateBetControls();
            
            addLogEntry(`${gameState.players[0].name} raises to $${gameState.betAmount}`);
        }

        function allIn() {
            const player = gameState.players[0];
            gameState.betAmount = player.stack;
            player.isAllIn = true;
            updateBetControls();
            
            addLogEntry(`${player.name} goes all in with $${player.stack}`);
        }

        function nextPlayer() {
            console.log(`Moving to next player. Current: ${gameState.currentPlayerIndex}, Phase: ${gameState.gamePhase}`);
            
            // Reset current player active state
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            currentPlayer.isActive = false;
            
            // Find next active player
            let nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            let rounds = 0;
            
            while (rounds < gameState.players.length) {
                const player = gameState.players[nextPlayerIndex];
                
                // Skip folded players and all-in players
                if (!player.isFolded && !player.isAllIn && player.stack > 0) {
                    break;
                }
                
                nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;
                rounds++;
            }
            
            gameState.currentPlayerIndex = nextPlayerIndex;
            const nextPlayer = gameState.players[gameState.currentPlayerIndex];
            nextPlayer.isActive = true;
            
            updateUI();
            
            // Check if betting round is complete
            if (isBettingRoundComplete()) {
                advanceGamePhase();
            } else {
                // If it's back to the human player, enable controls
                if (gameState.currentPlayerIndex === 0) {
                    enablePlayerControls();
                } else {
                    // AI player's turn
                    simulateAIPlayer();
                }
            }
        }

        function isBettingRoundComplete() {
            let activeNonAllInPlayers = 0;
            let playersMatchedBet = 0;
            
            // Count active players who can still act
            for (const player of gameState.players) {
                if (!player.isFolded && player.stack > 0) {
                    if (!player.isAllIn) {
                        activeNonAllInPlayers++;
                        
                        if (player.bet === gameState.currentBet) {
                            playersMatchedBet++;
                        }
                    }
                }
            }
            
            console.log(`Betting round check: ${activeNonAllInPlayers} active players, ${playersMatchedBet} matched bet`);
            
            // If only one player remains (others folded), betting round is complete
            const activePlayers = gameState.players.filter(p => !p.isFolded && p.stack > 0).length;
            if (activePlayers <= 1) {
                console.log("Only one active player - betting round complete");
                return true;
            }
            
            // All non-all-in players have matched the current bet
            // AND we've completed a full betting round (action has returned to the last raiser)
            const allMatched = activeNonAllInPlayers === 0 || playersMatchedBet === activeNonAllInPlayers;
            
            // Additional check: make sure we've completed a full betting round
            // The betting round is complete when action returns to the player who made the last raise
            // or when all subsequent players have called
            if (allMatched) {
                console.log("All players have matched the bet - checking if betting round is complete");
                
                // Check if we've completed a full round of betting
                // The round is complete when the action returns to the first player who hasn't folded
                // and all players have had a chance to act
                if (gameState.currentPlayerIndex === gameState.firstPlayerIndex) {
                    console.log("Betting round complete - action returned to first player");
                    return true;
                }
            }
            
            return false;
        }

        function advanceGamePhase() {
            // Reset betting state
            gameState.currentBet = 0;
            gameState.lastRaiseAmount = 0;
            
            // Reset player bets for new betting round
            gameState.players.forEach(player => {
                player.bet = 0;
            });
            
            // Check if we should skip to showdown (only one player remains)
            const activePlayers = gameState.players.filter(p => !p.isFolded && p.stack > 0).length;
            if (activePlayers <= 1) {
                gameState.gamePhase = 'showdown';
                determineWinner();
                return;
            }
            
            // Advance to next phase
            switch (gameState.gamePhase) {
                case 'preflop':
                    gameState.gamePhase = 'flop';
                    dealFlop();
                    break;
                case 'flop':
                    gameState.gamePhase = 'turn';
                    dealTurn();
                    break;
                case 'turn':
                    gameState.gamePhase = 'river';
                    dealRiver();
                    break;
                case 'river':
                    gameState.gamePhase = 'showdown';
                    determineWinner();
                    return; // Don't continue to next player
                default:
                    break;
            }
            
            // Set first player for this betting round (the player after the dealer)
            gameState.firstPlayerIndex = (gameState.dealerPosition + 1) % gameState.players.length;
            
            // Skip folded players for first player
            while (gameState.players[gameState.firstPlayerIndex].isFolded || 
                   gameState.players[gameState.firstPlayerIndex].stack === 0) {
                gameState.firstPlayerIndex = (gameState.firstPlayerIndex + 1) % gameState.players.length;
            }
            
            gameState.currentPlayerIndex = gameState.firstPlayerIndex;
            gameState.players[gameState.currentPlayerIndex].isActive = true;
            
            updateUI();
            addLogEntry(`Betting round: ${gameState.gamePhase}`);
            
            // If it's the human player's turn, enable controls
            if (gameState.currentPlayerIndex === 0) {
                enablePlayerControls();
            } else {
                // AI player's turn
                simulateAIPlayer();
            }
        }

        function dealFlop() {
            // Burn one card
            gameState.deck.pop();
            
            // Deal three community cards
            for (let i = 0; i < 3; i++) {
                gameState.communityCards.push(gameState.deck.pop());
            }
            
            addLogEntry("Flop dealt");
        }

        function dealTurn() {
            // Burn one card
            gameState.deck.pop();
            
            // Deal one community card
            gameState.communityCards.push(gameState.deck.pop());
            
            addLogEntry("Turn dealt");
        }

        function dealRiver() {
            // Burn one card
            gameState.deck.pop();
            
            // Deal one community card
            gameState.communityCards.push(gameState.deck.pop());
            
            addLogEntry("River dealt");
        }

        function determineWinner() {
            // Update all cards to be visible
            updatePlayerCards();
            
            // Evaluate hands for all active players
            const activePlayers = gameState.players.filter(player => !player.isFolded);
            
            if (activePlayers.length === 1) {
                // Only one player left, they win
                const winner = activePlayers[0];
                winner.stack += gameState.pot;
                addLogEntry(`${winner.name} wins $${gameState.pot} (all others folded)`);
            } else {
                // Multiple players, evaluate hands
                let bestHand = null;
                let winners = [];
                
                for (const player of activePlayers) {
                    const hand = evaluateHand(player.cards, gameState.communityCards);
                    
                    if (!bestHand || hand.rank > bestHand.rank) {
                        bestHand = hand;
                        winners = [player];
                    } else if (hand.rank === bestHand.rank) {
                        // Compare equivalent hands
                        if (compareHands(hand, bestHand) > 0) {
                            bestHand = hand;
                            winners = [player];
                        } else if (compareHands(hand, bestHand) === 0) {
                            winners.push(player);
                        }
                    }
                }
                
                // Split pot among winners
                const share = Math.floor(gameState.pot / winners.length);
                winners.forEach(winner => {
                    winner.stack += share;
                    addLogEntry(`${winner.name} wins $${share} with ${bestHand.name}`);
                });
                
                // Handle any odd chips
                const remainder = gameState.pot % winners.length;
                if (remainder > 0) {
                    winners[0].stack += remainder;
                    addLogEntry(`${winners[0].name} gets extra $${remainder} (odd chip)`);
                }
            }
            
            // Reset pot
            gameState.pot = 0;
            
            // Update UI
            updateUI();
            
            // Wait a bit then start new hand
            setTimeout(() => {
                startNewHand();
            }, 5000);
        }

        function evaluateHand(playerCards, communityCards) {
            const allCards = [...playerCards, ...communityCards];
            
            // Sort cards by rank value
            allCards.sort((a, b) => getRankValue(b.rank) - getRankValue(a.rank));
            
            // Check for flush
            const flush = checkFlush(allCards);
            if (flush) {
                // Check for straight flush
                const straightFlush = checkStraight(flush.cards);
                if (straightFlush) {
                    // Check for royal flush
                    if (straightFlush.highestRank === 'A') {
                        return {
                            rank: handRankings['royal-flush'],
                            name: 'Royal Flush',
                            cards: straightFlush.cards
                        };
                    }
                    
                    return {
                        rank: handRankings['straight-flush'],
                        name: 'Straight Flush',
                        cards: straightFlush.cards,
                        highestRank: straightFlush.highestRank
                    };
                }
                
                return {
                    rank: handRankings['flush'],
                    name: 'Flush',
                    cards: flush.cards.slice(0, 5)
                };
            }
            
            // Check for straight
            const straight = checkStraight(allCards);
            if (straight) {
                return {
                    rank: handRankings['straight'],
                    name: 'Straight',
                    cards: straight.cards,
                    highestRank: straight.highestRank
                };
            }
            
            // Check for other hand types
            const rankCounts = {};
            allCards.forEach(card => {
                rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
            });
            
            const pairs = [];
            let threeOfAKind = null;
            let fourOfAKind = null;
            
            for (const [rank, count] of Object.entries(rankCounts)) {
                if (count === 4) {
                    fourOfAKind = rank;
                } else if (count === 3) {
                    threeOfAKind = rank;
                } else if (count === 2) {
                    pairs.push(rank);
                }
            }
            
            if (fourOfAKind) {
                return {
                    rank: handRankings['four-of-a-kind'],
                    name: 'Four of a Kind',
                    cards: allCards.filter(card => card.rank === fourOfAKind).slice(0, 4)
                };
            }
            
            if (threeOfAKind && pairs.length >= 1) {
                return {
                    rank: handRankings['full-house'],
                    name: 'Full House',
                    cards: allCards.filter(card => card.rank === threeOfAKind || card.rank === pairs[0]).slice(0, 5)
                };
            }
            
            if (threeOfAKind) {
                return {
                    rank: handRankings['three-of-a-kind'],
                    name: 'Three of a Kind',
                    cards: allCards.filter(card => card.rank === threeOfAKind).slice(0, 3)
                };
            }
            
            if (pairs.length >= 2) {
                // Sort pairs by rank value
                pairs.sort((a, b) => getRankValue(b) - getRankValue(a));
                return {
                    rank: handRankings['two-pair'],
                    name: 'Two Pair',
                    cards: allCards.filter(card => card.rank === pairs[0] || card.rank === pairs[1]).slice(0, 4)
                };
            }
            
            if (pairs.length === 1) {
                return {
                    rank: handRankings['pair'],
                    name: 'Pair',
                    cards: allCards.filter(card => card.rank === pairs[0]).slice(0, 2)
                };
            }
            
            // High card
            return {
                rank: handRankings['high-card'],
                name: 'High Card',
                cards: [allCards[0]]
            };
        }

        function checkFlush(cards) {
            const suitsCount = {};
            cards.forEach(card => {
                suitsCount[card.suit] = (suitsCount[card.suit] || 0) + 1;
            });
            
            for (const [suit, count] of Object.entries(suitsCount)) {
                if (count >= 5) {
                    return {
                        suit: suit,
                        cards: cards.filter(card => card.suit === suit)
                    };
                }
            }
            
            return null;
        }

        function checkStraight(cards) {
            // Create a set of unique ranks
            const uniqueRanks = [...new Set(cards.map(card => card.rank))];
            
            // Sort by rank value
            uniqueRanks.sort((a, b) => getRankValue(b) - getRankValue(a));
            
            // Check for straight (A can be high or low)
            for (let i = 0; i <= uniqueRanks.length - 5; i++) {
                if (isConsecutive(uniqueRanks.slice(i, i + 5))) {
                    return {
                        highestRank: uniqueRanks[i],
                        cards: cards.filter(card => 
                            uniqueRanks.slice(i, i + 5).includes(card.rank)
                        ).slice(0, 5)
                    };
                }
            }
            
            // Check for wheel (A-2-3-4-5)
            if (uniqueRanks.includes('A') && 
                uniqueRanks.includes('2') && 
                uniqueRanks.includes('3') && 
                uniqueRanks.includes('4') && 
                uniqueRanks.includes('5')) {
                return {
                    highestRank: '5',
                    cards: cards.filter(card => 
                        ['A', '2', '3', '4', '5'].includes(card.rank)
                    ).slice(0, 5)
                };
            }
            
            return null;
        }

        function isConsecutive(ranks) {
            for (let i = 0; i < ranks.length - 1; i++) {
                if (getRankValue(ranks[i]) - 1 !== getRankValue(ranks[i + 1])) {
                    return false;
                }
            }
            return true;
        }

        function getRankValue(rank) {
            const values = {
                '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, 
                '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14
            };
            return values[rank];
        }

        function compareHands(hand1, hand2) {
            // Compare by rank first
            if (hand1.rank !== hand2.rank) {
                return hand1.rank - hand2.rank;
            }
            
            // For same rank, compare highest cards
            const cards1 = hand1.cards.map(card => getRankValue(card.rank)).sort((a, b) => b - a);
            const cards2 = hand2.cards.map(card => getRankValue(card.rank)).sort((a, b) => b - a);
            
            for (let i = 0; i < Math.min(cards1.length, cards2.length); i++) {
                if (cards1[i] !== cards2[i]) {
                    return cards1[i] - cards2[i];
                }
            }
            
            return 0; // Hands are equal
        }

        function enablePlayerControls() {
            console.log("Enabling player controls");
            
            // Enable all action buttons
            document.getElementById('fold-btn').disabled = false;
            document.getElementById('check-btn').disabled = false;
            document.getElementById('call-btn').disabled = false;
            document.getElementById('raise-btn').disabled = false;
            document.getElementById('allin-btn').disabled = false;
            document.getElementById('place-bet-btn').disabled = false;
            
            // Update button states based on game situation
            const player = gameState.players[0];
            const callAmount = gameState.currentBet - player.bet;
            
            // Enable/disable check button
            document.getElementById('check-btn').disabled = callAmount > 0;
            
            // Enable/disable call button
            document.getElementById('call-btn').disabled = callAmount <= 0 || callAmount > player.stack;
            
            // Update call button text
            document.getElementById('call-btn').textContent = `Call $${callAmount > 0 ? callAmount : 0}`;
            
            // Enable/disable raise button
            const minRaise = gameState.currentBet + (gameState.lastRaiseAmount || gameState.bigBlindAmount);
            document.getElementById('raise-btn').disabled = minRaise > player.stack;
            
            // Enable/disable all-in button
            document.getElementById('allin-btn').disabled = player.stack <= 0;
        }

        function disablePlayerControls() {
            // Disable all action buttons
            document.getElementById('fold-btn').disabled = true;
            document.getElementById('check-btn').disabled = true;
            document.getElementById('call-btn').disabled = true;
            document.getElementById('raise-btn').disabled = true;
            document.getElementById('allin-btn').disabled = true;
            document.getElementById('place-bet-btn').disabled = true;
        }

        function simulateAIPlayer() {
            console.log(`AI Player ${gameState.currentPlayerIndex} turn`);
            
            // Disable player controls during AI turn
            disablePlayerControls();
            
            // Add a small delay to simulate thinking
            setTimeout(() => {
                const aiPlayer = gameState.players[gameState.currentPlayerIndex];
                const callAmount = gameState.currentBet - aiPlayer.bet;
                
                // Simple AI logic
                let action;
                
                if (callAmount === 0) {
                    // Can check
                    action = Math.random() < 0.7 ? 'check' : 'raise';
                } else {
                    // Must call, fold, or raise
                    const rand = Math.random();
                    if (rand < 0.3) {
                        action = 'fold';
                    } else if (rand < 0.7) {
                        action = 'call';
                    } else {
                        action = 'raise';
                    }
                }
                
                // Execute AI action
                switch (action) {
                    case 'fold':
                        aiPlayer.isFolded = true;
                        aiPlayer.isActive = false;
                        addLogEntry(`${aiPlayer.name} folds`);
                        break;
                        
                    case 'check':
                        addLogEntry(`${aiPlayer.name} checks`);
                        break;
                        
                    case 'call':
                        const actualCall = Math.min(callAmount, aiPlayer.stack);
                        aiPlayer.bet += actualCall;
                        aiPlayer.stack -= actualCall;
                        gameState.pot += actualCall;
                        addLogEntry(`${aiPlayer.name} calls $${actualCall}`);
                        break;
                        
                    case 'raise':
                        const minRaise = gameState.currentBet + (gameState.lastRaiseAmount || gameState.bigBlindAmount);
                        const maxRaise = aiPlayer.stack;
                        const raiseAmount = Math.min(
                            Math.max(minRaise, Math.floor(maxRaise * 0.3)),
                            maxRaise
                        );
                        
                        aiPlayer.bet += raiseAmount;
                        aiPlayer.stack -= raiseAmount;
                        gameState.pot += raiseAmount;
                        gameState.currentBet = aiPlayer.bet;
                        gameState.lastRaiseAmount = raiseAmount;
                        addLogEntry(`${aiPlayer.name} raises to $${aiPlayer.bet}`);
                        break;
                }
                
                updateUI();
                
                // Move to next player
                nextPlayer();
            }, 1000 + Math.random() * 1000); // Random delay between 1-2 seconds
        }

        function addLogEntry(message) {
            const logEntries = document.getElementById('log-entries');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            logEntries.appendChild(entry);
            logEntries.scrollTop = logEntries.scrollHeight;
        }
    </script>
</body>
</html>